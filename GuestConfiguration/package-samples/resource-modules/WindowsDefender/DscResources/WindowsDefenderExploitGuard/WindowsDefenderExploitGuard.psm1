Import-Module -Name 'Defender'

function Get-NameforAttackSurfaceReductionRuleId
{
    [CmdletBinding()]
    [OutputType([String])]
    param
    (
        [Parameter(Mandatory = $true)]
        [String]
        $Id
    )

    $attackRuleIdToName = @{
        'be9ba2d9-53ea-4cdc-84e5-9b1eeee46550' = 'Block executable content from email client and webmail'
        'b2b3f03d-6a65-4f7b-a9c7-1c7ef74a9ba4' = 'Block untrusted and unsigned processes that run from USB'
        '9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2' = 'Block credential stealing from the Windows local security authority subsystem (lsass.exe)'
        'd4f940ab-401b-4efc-aadc-ad5f3c50688a' = 'Block all Office applications from creating child processes'
        'd3e037e1-3eb8-44c8-a917-57927947596d' = 'Block JavaScript or VBScript from launching downloaded executable content'
        '5beb7efe-fd9a-4556-801d-275e5ffc04cc' = 'Block execution of potentially obfuscated scripts'
        '3b576869-a4ec-4529-8536-b80a7769e899' = 'Block Office applications from creating executable content'
        '26190899-1602-49e8-8b27-eb1d0a1ce869' = 'Block Office communication application from creating child processes'
        '92E97FA1-2EDF-4476-BDD6-9DD0B4DDDC7B' = 'Block Win32 API calls from Office macro'
        '7674ba52-37eb-4a4f-a9a1-f0f9a1619a2c' = 'Block Adobe Reader from creating child processes'
        '75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84' = 'Block Office applications from injecting code into other processes'
    }

    return $attackRuleIdToName[$Id]
}

function Get-ReasonsExploitGuardNotEnabled
{
    [CmdletBinding()]
    [OutputType([Hashtable[]])]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateSet('Compliant', 'Non-Compliant')]
        [String]
        $NotAvailableMachineState
    )

    $reasons = @()
    $reasonCodePrefix = 'WindowsDefender:WindowsDefenderExploitGuard'

    # Check OS Version - Minimum version allowed is Windows 10, update 1709
    $minimumOSVersionRequired = [Version]"10.0.16299"

    # The version of PS6 we use for policy has a bug retrieving the OS version which requires us to use full PS
    $osVersion = powershell -OutputFormat 'Xml' -NonInteractive -Command {[Environment]::OSVersion.Version}

    if ($osVersion -lt $minimumOSVersionRequired)
    {
        if ($NotAvailableMachineState -eq 'Non-Compliant')
        {
            $reason = @{
                Code = $reasonCodePrefix + ':ExploitGuardNotAvailable'
                Phrase = "The Windows Defender Exploit Guard feature is not available on machines older than Windows 10, update 1709 (OS version '$($minimumOSVersionRequired.ToString())'). The OS version of this machine is '$($osVersion.ToString())'."
            }
            $reasons += $reason
        }

        return $reasons
    }

    # Explanation of GUIDS can be found here: https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-exploit-guard/attack-surface-reduction-exploit-guard
    $expectedValues = @{
        EnableControlledFolderAccess = 0
        AttackSurfaceReductionRules_Actions = 1
        AttackSurfaceReductionRules_Ids = @(
            'be9ba2d9-53ea-4cdc-84e5-9b1eeee46550',
            'b2b3f03d-6a65-4f7b-a9c7-1c7ef74a9ba4',
            '9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2',
            'd4f940ab-401b-4efc-aadc-ad5f3c50688a',
            'd3e037e1-3eb8-44c8-a917-57927947596d',
            '5beb7efe-fd9a-4556-801d-275e5ffc04cc',
            '3b576869-a4ec-4529-8536-b80a7769e899',
            '26190899-1602-49e8-8b27-eb1d0a1ce869',
            '92E97FA1-2EDF-4476-BDD6-9DD0B4DDDC7B',
            '7674ba52-37eb-4a4f-a9a1-f0f9a1619a2c',
            '75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84'
        )
    }

    # Gets information about the configuration of Windows Defender
    $mpPreference = Get-MpPreference
    if ($null -eq $mpPreference)
    {
        $reason = @{
            Code = $reasonCodePrefix + ':FailedToRetrieveMpPreference'
            Phrase = "Failed to retrieve the preferences for Windows Defender scans and updates on this machine."
        }
        $reasons += $reason
    }
    else
    {
        # Check that Controlled Folder Access is enabled
        if ($mpPreference.EnableControlledFolderAccess -eq $expectedValues.EnableControlledFolderAccess)
        {
            Write-Verbose -Message "Controlled Folder Access is enabled on this machine."
        }
        else
        {
            $reason = @{
                Code = $reasonCodePrefix + ':ControlledFolderAccessNotEnabled'
                Phrase = "Controlled Folder Access is not enabled on this machine. The current value is '$($mpPreference.EnableControlledFolderAccess)', but the expected value is '$($expectedValues.EnableControlledFolderAccess)'."
            }
            $reasons += $reason
        }

        # Check the configured action for ASR rules
        if ($mpPreference.AttackSurfaceReductionRules_Actions -eq $expectedValues.AttackSurfaceReductionRules_Actions)
        {
            Write-Verbose -Message "The AttackSurfaceReductionRules_Actions setting is correct on this machine."
        }
        else
        {
            $reason = @{
                Code = $reasonCodePrefix + ':AttackSurfaceReductionRulesActionsNotCorrect'
                Phrase = "The AttackSurfaceReductionRules_Actions setting is not correct on this machine. The current value is '$($mpPreference.AttackSurfaceReductionRules_Actions)', but the expected value is '$($expectedValues.AttackSurfaceReductionRules_Actions)'."
            }
            $reasons += $reason
        }

        # Verify that the list of ASR rules contains the ASC recomendations
        foreach ($expectedId in $expectedValues.AttackSurfaceReductionRules_Ids)
        {
            if ($mpPreference.AttackSurfaceReductionRules_Ids -contains $expectedId)
            {
                Write-Verbose -Message "Expected ID '$expectedID' found in AttackSurfaceReductionRules_Ids on this machine."
            }
            else
            {
                $ruleName = Get-NameforAttackSurfaceReductionRuleId -Id $expectedID
                $reason = @{
                    Code = $reasonCodePrefix + ':AttackSurfaceReductionRulesIdMissing'
                    Phrase = "The ID '$expectedID' is missing from AttackSurfaceReductionRules_Ids on this machine. This ID corresponds to the rule with the name '$ruleName'."
                }
                $reasons += $reason
            }
        }
    }

    return $reasons
}

function Get-TargetResource
{
    [CmdletBinding()]
    [OutputType([Hashtable])]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateSet('Yes')]
        [String]
        $IsSingleInstance,

        [Parameter(Mandatory = $true)]
        [ValidateSet('Compliant', 'Non-Compliant')]
        [String]
        $NotAvailableMachineState
    )

    $exploitGuardInfo = @{
        IsSingleInstance = 'Yes'
        NotAvailableMachineState = $NotAvailableMachineState
    }

    $reasons = @(Get-ReasonsExploitGuardNotEnabled -NotAvailableMachineState $NotAvailableMachineState)

    if ($null -ne $reasons -and $reasons.Count -gt 0)
    {
        $exploitGuardInfo['Reasons'] = $reasons
    }

    return $exploitGuardInfo
}

function Test-TargetResource
{
    [CmdletBinding()]
    [OutputType([Boolean])]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateSet('Yes')]
        [String]
        $IsSingleInstance,

        [Parameter(Mandatory = $true)]
        [ValidateSet('Compliant', 'Non-Compliant')]
        [String]
        $NotAvailableMachineState
    )

    $reasons = @(Get-ReasonsExploitGuardNotEnabled -NotAvailableMachineState $NotAvailableMachineState)

    if ($null -ne $reasons -and $reasons.Count -gt 0)
    {
        return $false
    }

    return $true
}

function Set-TargetResource
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [ValidateSet('Yes')]
        [String]
        $IsSingleInstance,

        [Parameter(Mandatory = $true)]
        [ValidateSet('Compliant', 'Non-Compliant')]
        [String]
        $NotAvailableMachineState
    )

    throw 'Set functionality is not supported in this version of the DSC resource.'
}
